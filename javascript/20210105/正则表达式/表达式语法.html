<!DOCTYPE html>
<html>

<head></head>

<body></body>
<script>
    // 百度百科：https://baike.baidu.com/item/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1700215?fr=aladdin

    // 声明正则表达式
    // 正则表达式中由正则符号和字符串构成
    let regex = /^$/ // 以对象形式声明正则表达式

    // 斜杠转义: 把特殊字符转成字符串
    regex = /\^/

    // ^ ：匹配字符串的开头
    regex = /^123(\S|\s)*/

    // $ : 匹配字符串的结尾
    regex = /(\S|\s)*万岁$/

    // ------------------- 匹配字符个数的表达式

    // * ：匹配前一个字符任意次数
    regex = /^123*456$/

    // + : 匹配前一个字符1次或多次（至少出现一次）
    regex = /^123+456$/

    // ?: 匹配前一个字符0次或者1次（是否出现过一次）
    regex = /^123?456$/

    // {n}: 匹配前一个字符指定次数
    regex = /^123{2}456$/

    // {n,}: 匹配前一个字符至少多少次
    regex = /^123{2,}456$/

    // {n, m}: 匹配前一个字符至少出现n次，至多出现m次
    regex = /^123{2,5}456$/

    // --------------------- 让匹配个数的表达式转换为非贪婪模式
    // 贪婪模式: 正则表达式在匹配字符串时，将尽可能多的匹配符合条件的字符
    // 非贪婪模式：正则表达式在匹配字符串时，将尽可能少的匹配符合条件的字符
    regex = /^1234+/g // 默认为贪婪模式
    let str = '12344444444'
    console.log(str.match(regex))
    
    // 在所有匹配字符个数的表达式(*、+、?、{n}、{n,}、{n,m})后面，加上 '?' 问好，就能转换为非贪婪模式
    regex = /^1234+?/g
    console.log(str.match(regex))

    // x|y 或：匹配x字符或y字符
    regex = /good|bad/
    str = 'items is not good' // 或者 'items is not bad' 也能匹配成功
    console.log(regex.test(str))

    // [xyz] : 匹配字符集合，只要字符在方括号中出现，都能匹配成功
    regex = /^[xyz]ok/
    
    // [^xyz]: 负值字符集合, 只要字符不再方括号中，就能成功匹配
    regex = /^[^xyz]ok/

    // [a-z]: 取范围值, 只要字符在a到z的范围之间，即匹配成功，多用在数字上
    regex = /[0-5][6-9]/ // 匹配第一个数为0~5第二个数为6~9的数字
    
    // [^a-z]: 取负范围值，只要字符不在a到z的范围之间，即匹配成功，多用在数字上
    regex = /[^0-5][^6-9]/

    // ------------------- 分组 (pattern)
    // 将一组内容作为一个字符进行匹配就是分组
    regex = /^123(goodIdea)+789$/
    
    // 站在字符串的角度看，圆括号的作用，不仅用于匹配正则表达式的字符串，还需要取值
    str = '123goodIdeagoodIdea789'
    // 最终的结果将包含正则表达式匹配成功的字符串 和 圆括号中的内容
    console.log(str.match(regex))
    
    // (?:pattern) : 匹配正则内容且不获取圆括号中的值
    regex = /^123(?:goodIdea)+789$/
    console.log(str.match(regex))

    // -------------------- 预查询
    // 预查询：正则表达式会去匹配预查询中的内容，但不会进行取值
    // 预查询分方向：前后

    // (?=pattern) 后置预查询
    regex = /Windows(?=95|98|2000|NT|PE)/
    str = 'Windows95'
    // 预查询将在匹配的时候进行查找，但调用str.match时不会获取预查询部分的内容
    // 所以上述例子，最终匹配后会得到：Windows
    console.log(str.match(regex))
    
    // (?!pattern) 负后置预查询
    regex = /Windows(?!95|98|2000|NT|PE)/
    
    // (?<=pattern) 前置预查询
    regex = /(?<=95|98|2000|NT|PE)Windows/
    str = 'PEWindows'
    console.log(str.match(regex))
    
    // (?<!pattern) 负前置预查询
    regex = /(?<!95|98|2000|NT|PE)Windows/


</script>

</html>